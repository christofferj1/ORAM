* General
The check boxes is to mark when something is added to the report
 - [X] At the client side, the server strategy is used to separate the algorithm logic from the server logic. The server layer handles the server socket and in/output streams. It also converts between byte[] and int addresses, so the ORAM logic can work with 'sane' types. Both the separation and the 'sane' data types makes it easier to test.
   - [X] Using no constants, except for stuff like key sizes, then everything works relatively to the parameters it is initialized with, and can therefore be scaled
 - [-] The block interface is a way to handle a block, which sometimes consists of some data and an address of some sort, which is nicely separated (by the server)
   - [-] There are different addresses for e.g. Path and lookahead (the later needs no address perhaps?)
 - [X] Dummy blocks get address 0, as they do in some article (Log^3 N)
 - [X] Address and data byte[] are padded by making sure all arrays are of same length (padded with zero's should enough when CPA secure encryption is used)
 - [X] The dummy block check is done in Util, so it can be changed in a central place if the strategy is changed
 - [X] Using 32 bytes for encrypted integers as it is easier with padding (less errors) and then I can get 16 bytes of randomness
   - [X] All integers are changed to byte arrays of size four before encryption, this pads them, so size does not disclose any information about addresses
 - [X] The access strategies assumes blocks are of correct size. This should simulate a RAM placed on third party hardware, it does not provide more than simple/stupid read write operations
 - [X] The server only get a single array of data for each block. The client must handle the format.
   - [X] The Server part at the client side turns every array into an encrypted block, where the address array comes from the first 32 bytes of the data
   - [X] Each ORAM strategy handle their individual data format
   - [ ] The server uses its own blocks (like Path blocks), which carries the address on the server, which is not send back to the client
 - [X] The server strategy can be switched out with a fake/stub, to simply run the local experiments, where it just manipulates an in memory array
 - [ ] Some of the code is duplicated in the two project, client and server, which could have been avoided with a common library.

* Lookahead
 - [X] Matrix is indexed such that the first 'matrixHeight' blocks are in the first column
 - [X] Different from how the algorithm is described, I read the entire column for the maintenance job together with the stashes and the block to fetch, to help speed up. That means I don't fetch a single block, when it is a part of the column for the maintenance.
 - [-] Access stash is implemented as a map of maps. Then I can retrieve and delete entire columns easily.
 - [X] Lookahead needs a setup where blocks are added, to make sure the blocks written/read have an address

* Path
 - [ ] Using bucket size 4